<!-- home.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coffee Brew Helper</title>
    <!-- Add any CSS links, meta tags, or other head elements here -->
    {% load static %}
    <style>
        /* Key Test Output*/
        .highlighted-step {
            /* Add your CSS styling for highlighting here */
            background-color: yellow; /* Example: Highlight the step with a yellow background */
        }
        .elapsed-time {
            margin-top: 10px;
        }

        /* Header styling */
        h2 {
            margin-top: 10px;
            margin-bottom: 10px; /* Reduce space below section headers */
        }

        /* Section Styling */
        .section {
            display: flex;
            flex-direction: column;
        }
        
        /* List Styling */
        ul {
            margin-top: 0px;
            line-height: 1.5; /* Adjust line spacing within sections */
        }

        /* Paragraph styling */
        p {
            margin-top: 0px;
        }

        /* Input Styling */
        input[type="text"] {
            background: none;
            border: none;
            outline: none;
            width: 80%;
        }

        /* Label Styling */
        label {
            font-weight: bold;
            margin: 0;
            padding: 0;
        }


    </style>
</head>
<body>
    <h1>Coffee Brew Helper</h1>
    <form action="{% url 'home' %}" method="GET">
        <label for="method-dropdown">Select Method:</label>
        <select id="method-dropdown" name="selected_method_id" onchange="populateRecipes()">
            <option value="">Select a Method</option>
            {% for method in methods %}
                <option value="{{ method.id }}">{{ method.name }}</option>
            {% endfor %}
        </select>

        <label for="recipe-dropdown">Select Recipe:</label>
        <select id="recipe-dropdown" name="selected_recipe_id">
            <option value="">Select a Recipe</option>
            <!-- Recipes will be populated dynamically using JavaScript -->
        </select>

        <input type="submit" value="Select">
    </form>
        
    {% if selected_recipe %}
        <div class="section">
            <h2>{{selected_recipe.name}}</h2>
            <!-- Element to display recipe header info -->
            <label id = "recipe-description-label" for="recipe-description">
                <span>Description: </span>
                <input type ="text" id="recipe-description" readonly value="{{ selected_recipe.description }}">
            </label>
            <label id = "recipe-coffee-weight-label" for="recipe-coffee-weight">
                <span>Total coffee: </span>
                <input type ="text" id="recipe-coffee-weight" readonly value="{{ selected_recipe.coffee_weight}}">
            </label>
            <label id = "recipe-target-total-water-label" for="recipe-target-total-water">
                <span>Total water: </span>
                <input type ="text" id="recipe-target-total-water" readonly value="{{ selected_recipe.target_total_water }}">
            </label>
            <label id = "recipe-brew-ratio-label" for="recipe-brew-ratio">
                <span>Brew ratio: </span>
                <input type ="text" id="recipe-brew-ratio" readonly value="{{ selected_recipe.brew_ratio }}">
            </label>
            <label id = "recipe-coffee-grind-size-label" for="recipe-coffee-grind-size">
                <span>Grind size: </span>
                <input type ="text" id="recipe-coffee-grind-size" readonly value="{{ selected_recipe.coffee_grind_size }}">
            </label>
            <label id = "recipe-temperature-label" for="recipe-temperature">
                <span>Temperature: </span>
                <input type ="text" id="recipe-temperature" readonly value="{{ selected_recipe.temperature }}">
            </label>
            <label id = "recipe-target-total-time-label" for="recipe-target-total-time">
                <span>Total time: </span>
                <input type ="text" id="recipe-target-total-time" readonly value="{{ selected_recipe.target_total_time }}">
            </label>
            <!-- Element to display elapsed time -->
            <div class="elapsed-time">
                <label id = "elapsed-time-label" for="elapsed-time">
                    <span>Elapsed Time: </span>
                    <input type="text" id="elapsed-time" readonly value="00:00">
                </label>
            </div>
        </div>
        
        <table border="1" id="brewing-steps">
            <thead>
                <tr>
                    <th>Step</th>
                    <th>Description</th>
                    <th>Change in Water</th>
                    <th>Target Water</th>
                    <th>Change in Time</th>
                    <th>Target Time</th>
                    <th>Executed Time</th>
                </tr>
            </thead>
            <tbody>
                {% for step in steps %}
                <tr>
                    <td>{{ step.order_id }}</td>
                    <td id="description-{{ step.order_id }}">{{ step.description }}</td>
                    <td>{{ step.change_in_water }}</td>
                    <td>{{ step.target_total_water }}</td>
                    <td id="change-in-time-{{ step.order_id }}">{{ step.change_in_time }}</td>
                    <td id="target-total-time-{{ step.order_id }}">{{ step.target_total_time }}</td>
                    <td id="executed-time-{{ step.order_id }}"></td>
                </tr>
                {% endfor %}
            </tbody>
        </table>

    <!-- Buttons for controlling the timer -->
    <audio id="startStepBeepSound" src="{% static 'brewhelper/audio/startStepBeep128.mp3' %}" type="audio/mpeg"></audio>
    <audio id="warningStepEndBeepsSound" src="{% static 'brewhelper/audio/warningStepEndBeeps128.mp3' %}" type="audio/mpeg"></audio>
    <button id="startPauseButton" onclick="toggleTimer()">Start</button>
    <button onclick="resetTimer()">Reset</button>
    <button onclick="onNextClicked()">Next</button>
    
    <!-- Speech Settings -->
    <div class="section">
        <h2>Speech Settings</h2>
        <p><!-- Checkbox for toggling read steps outloud feature -->
            <label for="toggleReadStepsOutloud">
                <input type ="checkbox" id="toggleReadStepsOutloud" onchange="toggleReadStepsOutloud()">
                <span><strong>Enable Read Steps Outloud</strong></span>
            </label>
        </p>
        <p><!-- Checkbox for toggling voice commands feature -->
            <label for="toggleVoiceCommands">
                <input type ="checkbox" id="toggleVoiceCommands" onchange="toggleVoiceCommands()">
                <span><strong>Enable Voice Commands</strong></span>
            </label>
        </p>
        <p class="detected-voice-command-label">
            <label for="detected-voice-command"><span>Last Detected Command: </span></label>
            <input type="text" id="detected-voice-command" readonly value="">
        </p>
        <p class="voice-command-list-title-label"><label>Accepted Commands:</label></p>
        <ul class="voice-command-list">
            <li>Start</li>
            <li>Pause</li>
            <li>Reset</li>
            <li>Next</li>
        </ul>
    </div>

    <!-- Keyboard shortcuts note -->
    <div class="section">
        <h2>Keyboard Shortcuts:</h2>
        <div class="keyboard-shortcut-info">
            <ul class="keyboard-shortcut-list">
                <li><strong>z:</strong> Start/Pause</li>
                <li><strong>x:</strong> Reset</li>
                <li><strong>c:</strong> Next</li>
            </ul>
        </div>
    </div>

    {% else %}
    <div class="section">
        <h2>[No Recipe Selected]</h2>
    </div>
    {% endif %}
    
    <!-- Add any JavaScript scripts or other body elements here -->
    <script>
        // General helpers ///////////////////////////////////////////////////
        function getTimeStringFromSeconds(seconds) {
            const minutes = Math.floor(seconds / 60); // Get minutes
            const remainingSeconds = seconds % 60; // Get remaining seconds

            const formattedMinutes = String(minutes).padStart(2, '0'); // Ensure 2-digit minutes
            const formattedSeconds = String(remainingSeconds).padStart(2, '0'); // Ensure 2-digit seconds

            return `${formattedMinutes}:${formattedSeconds}`; // Format as "mm:ss"
        }
        function getSecondsFromTimeString(timeString) {
            const [minutes, seconds] = timeString.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        // Selecting the recipe //////////////////////////////////////////////
        // Function to populate recipe dropdown base on method
        async function populateRecipes() {
            return new Promise((resolve, reject) => {
                const methodDropdown = document.getElementById('method-dropdown');
                const selectedMethodId = methodDropdown.value;
                const recipeDropdown = document.getElementById('recipe-dropdown');

                // Clear previous options in the recipe dropdown
                recipeDropdown.innerHTML = '<option value="">Select a Recipe</option>';

                if (selectedMethodId !== '') {
                    // AJAX call to fetch recipes associated with the selected method
                    fetch(`/get-recipes?method_id=${selectedMethodId}`)
                        .then(response => response.json())
                        .then(data => {
                            data.forEach(recipe => {
                                const option = document.createElement('option');
                                option.value = recipe.id;
                                option.textContent = recipe.name;
                                recipeDropdown.appendChild(option);
                            });
                            resolve(); // Resolve the Promise once fetching and populating is done
                        })
                        .catch(error => {
                            console.error('Error fetching recipes:', error);
                            reject(error); // Reject the Promise in case of an error
                        });
                } else {
                    resolve(); // Resolve immediately if no method is selected
                }
            });
        }
       
        document.addEventListener('DOMContentLoaded', () => {
            // After Select is hit or the page is refreshed, retain selected method and recipe
            const methodDropdown = document.getElementById('method-dropdown');
            const recipeDropdown = document.getElementById('recipe-dropdown');

            const urlParams = new URLSearchParams(window.location.search);
            const selectedMethodId = urlParams.get('selected_method_id');
            const selectedRecipeId = urlParams.get('selected_recipe_id');
            
            if (selectedMethodId) {
                methodDropdown.value = selectedMethodId;
                // Populate recipes based on the selected method and set the currently selected recipe
                populateRecipes()
                    .then(() => {
                        if (selectedRecipeId) {
                            recipeDropdown.value = selectedRecipeId;
                        }
                    })
                    .catch(error => {
                        // Handle any errors that occurred during populateRecipes
                        console.error('Error in populateRecipes:', error);
                    });
            }

            // Shortcut keys
            document.addEventListener('keydown', event => {
                switch (event.key) {
                    case 'z':
                    case 'Z':
                        toggleTimer(); // Start/Pause when Z key is pressed
                        break;
                    case 'x':
                    case 'X':
                        resetTimer(); // Reset when X key is pressed
                        break;
                    case 'c':
                    case 'C':
                        onNextClicked(); // Next operation when C key is pressed
                        break;
                    default:
                        break;
                }
            });
            
            // Initialize read outloud
            // Wait for voice list to load (aync to the page) before using them in speech functions
            window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = function(){
                voices = window.speechSynthesis.getVoices();
            }
            // Initialize voice commands
            initVoiceCommands();
        });
        
        // Speech Features ///////////////////////////////////////////////////////
        // read steps outloud ////
        let isReadStepsOutloud = false;
        let voices;
        // Function to set read steps outloud flag based on checkbox state
        function toggleReadStepsOutloud() {
            const checkbox = document.getElementById('toggleReadStepsOutloud');
            isReadStepsOutloud = checkbox.checked;
            if (!isReadStepsOutloud) {
                cancelReadStepDescription();
            }
        }
        // Function to read the description aloud
        function readStepDescription() {
            if (!isReadStepsOutloud){
                return;
            }
            // Clear old utterances
            cancelReadStepDescription();
            // Create utterance from latest step description
            const description = rows[stepIndex].querySelector('[id^="description-"]').textContent
            const utterance = new SpeechSynthesisUtterance(description);
            // set voice
            utterance.voice = voices[4]; //for now we hardcode one
            // Read description
            window.speechSynthesis.speak(utterance);
        }
        // Function to pause reading description
        function pauseReadStepDescription(){
            if (window.speechSynthesis.speaking){
                window.speechSynthesis.pause();
            }
        }
        // Function to cancel reading all descriptions
        function cancelReadStepDescription(){
            if (window.speechSynthesis.speaking){
                window.speechSynthesis.cancel();
            }
        }

        // voice commands for Voice Commands ////
        let voiceCommands;
        // Function to initialize voice commands
        function initVoiceCommands() {
            // Check browser support for SpeechRecognition
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                voiceCommands = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

                // Configure voice commands
                voiceCommands.continuous = false; // Enable continuous recognition
                voiceCommands.lang = 'en-US'; // Set the language
                voiceCommands.interimResults = false; // Set to true for interim results
                
                // Define commands and associate with functions                
                isAutoRestart = true;
                
                voiceCommands.onresult = event => {
                    const lastResultIndex = event.results.length - 1;
                    const speechResult = event.results[lastResultIndex][0].transcript.toLowerCase();
                    
                    // Split the speechResult into words and extract the last word spoken
                    const words = speechResult.split(' ');
                    const lastWord = words[words.length - 1];
                    
                    // Compare last word to accepted list of commands
                    switch (lastWord) {
                        case 'start':
                        case 'pause':
                            toggleTimer(); // Start/Pause operation
                            break;
                        case 'reset':
                            resetTimer(); // Reset operation
                            break;
                        case 'next':
                            onNextClicked(); // Next operation
                            break;
                        default:
                            break;
                    }
                    // Update user with last word detected
                    updateDetectedVoiceCommand(lastWord)
                };

                // Handle errors and other events
                voiceCommands.onerror = event => {
                    switch(event.error){
                        case 'not-allowed':
                        case 'service-not-allowed':
                            // if permission to use the mic is denied, turn off auto-restart
                            isAutoRestart = false;
                            break;
                    }
                    console.error('voice commands error:', event.error);
                };

                // Start/stop voice commands based on checkbox state
                toggleVoiceCommands();

                // Restart recognition after it ends to enable continuous listening
                voiceCommands.onend = () => {
                    //updateDetectedVoiceCommand(); //clear shown detected command
                    if (isAutoRestart){
                        voiceCommands.start(); // Restart recognition after it ends
                    }
                };
            } else {
                console.log('voice commands not supported.');
            }
        }
        // Function to toggle voice commands based on checkbox state
        function toggleVoiceCommands() {
            if (voiceCommands) {
                const checkbox = document.getElementById('toggleVoiceCommands');
                if (checkbox.checked) {
                    isAutoRestart = true;
                    voiceCommands.start(); // Start voice commands
                } else {
                    updateDetectedVoiceCommand(); //clear shown detected command
                    isAutoRestart = false;
                    voiceCommands.stop(); // Stop voice commands
                }
            }
        }
        // Function to update detected voice command in the input element, defaults to empty string (clear)
        function updateDetectedVoiceCommand(detecedVoiceCommandResult = "[No Word Detected]") {
            const detecedVoiceCommandInput = document.getElementById('detected-voice-command');
            detecedVoiceCommandInput.value = detecedVoiceCommandResult ; // Update input value with speech recognition result
        }

        ////////////////////////////////////////////////////////////////////////
        // Update time data in header info
        const recipeTargetTotalTime = document.getElementById('recipe-target-total-time');
        recipeTargetTotalTime.value = getTimeStringFromSeconds(recipeTargetTotalTime.value);

        // Get all rows of the table
        const rows = document.querySelectorAll('#brewing-steps tbody tr');
        
        let stepIndex = 0;
        let executedStepIndex = 0;
        let elapsedTime = 0;
        let timer;

        let isTimerRunning = false;

        // Update the Time cells in the table        
        function updateTimeCells(timeCells){
            timeCells.forEach(cell => {
            const timeInSeconds = parseInt(cell.textContent);
            cell.textContent = getTimeStringFromSeconds(timeInSeconds);
            });
        }
        const totalTargetTimeCells = document.querySelectorAll('[id^="target-total-time-"]');
        const changeInTimeCells = document.querySelectorAll('[id^="change-in-time-"]');
        updateTimeCells(totalTargetTimeCells)
        updateTimeCells(changeInTimeCells)

        // Function to remove higlight from all steps
        function removeHighlightStep(){
            rows.forEach(row => {
                row.classList.remove('highlighted-step'); // Remove highlight from all rows
            });
        }
        // Function to highlight the current step
        function highlightStep() {
            if (stepIndex < rows.length){
                removeHighlightStep();
                rows[stepIndex].classList.add('highlighted-step'); // Highlight the current step
            }
        }

        // Function to update elapsed time in the input element
        function updateElapsedTime() {
            const elapsedTimeInput = document.getElementById('elapsed-time');
            const formattedTime = getTimeStringFromSeconds(elapsedTime); // Convert elapsed time to "mm:ss"
            elapsedTimeInput.value = formattedTime; // Update input value with formatted time
        }
        
        function toggleTimer() {
            const startPauseButton = document.getElementById('startPauseButton');

            if (!isTimerRunning) { 
                startTimer();
                startPauseButton.textContent = 'Pause'; // Change button text to 'Pause'
            } else {
                pauseTimer();
                startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            }

            isTimerRunning = !isTimerRunning; // Toggle timer status
        }

        // Function to start the timer and highlight steps based on target_total_time
        function startTimer() {
            if (elapsedTime === 0){
                const startStepAudio = document.getElementById('startStepBeepSound');
                startStepAudio.play();
            }
            highlightStep();
            readStepDescription();
            timer = setInterval(() => {
                elapsedTime += 1; // Increment elapsed time (assuming 1 second intervals)
                updateElapsedTime(); // Update elapsed time in the input element
                // Highlight the current step
                if (stepIndex >= rows.length) {
                    // Don't stop timer as it will disrupt the executed completed time
                } else {
                    const currentStepTotalTime = getSecondsFromTimeString(rows[stepIndex].querySelector('[id^="target-total-time-"]').textContent);
                    
                    // Play warning beep 3 seconds before step change
                    if (elapsedTime >= currentStepTotalTime - 3) {
                        const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
                        if (warningStepEndAudio.paused){
                            warningStepEndAudio.play();
                        }
                    }
                    
                    if (elapsedTime >= currentStepTotalTime) {
                        stepIndex++;
                        const startStepAudio = document.getElementById('startStepBeepSound');
                        if (startStepAudio.paused){
                            startStepAudio.play();
                        }
                        highlightStep();
                        readStepDescription();
                    }
                }
            }, 1000); // Timer interval: 1 second (adjust as needed)
        }
        // Function to stop the timer
        function pauseTimer() {
            clearInterval(timer);
            const startStepAudio = document.getElementById('startStepBeepSound');
            startStepAudio.pause();
            const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
            warningStepEndAudio.pause();
            cancelReadStepDescription(); //better to cancel and restart reading
        }

        // Function to reset the timer and step index
        function resetTimer() {
            // Stop the timer
            pauseTimer(timer);
            const startPauseButton = document.getElementById('startPauseButton');
            startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            isTimerRunning = false;
        
            // Reset test parameters
            stepIndex = 0;
            executedStepIndex = 0;
            elapsedTime = 0;
            const startStepAudio = document.getElementById('startStepBeepSound');
            startStepAudio.currentTime = 0;
            const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
            warningStepEndAudio.currentTime = 0;
            cancelReadStepDescription();
            removeHighlightStep();
            updateElapsedTime(); // Update elapsed time in the input element

            // Clear the executed-time column
            const timeTakenCells = document.querySelectorAll('[id^="executed-time-"]');
            timeTakenCells.forEach(cell => {
                cell.textContent = ''; // Clear the content of executed-time cells
            });
        }

        // Function to record time taken and update step
        function onNextClicked() {
            // Record current time for the current step
            const currentStepId = executedStepIndex + 1; // Assuming stepIndex starts from 0
            const timeTakenCell = document.getElementById(`executed-time-${currentStepId}`);
            timeTakenCell.textContent = getTimeStringFromSeconds(elapsedTime);

            // Update step for the user
            executedStepIndex++; // Increment step index for the user
        }
    </script>
</body>
</html>
