<!-- home.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coffee Brew Helper</title>
    <!-- Add any CSS links, meta tags, or other head elements here -->
    <style>
        .highlighted-step {
            /* Add your CSS styling for highlighting here */
            background-color: yellow; /* Example: Highlight the step with a yellow background */
        }
        /* General information styling */
        .general-info {
            display: flex;
            flex-direction: column;
        }
        .general-info input[type="text"] {
            background: none;
            border: none;
            outline: none;
            /* Additional styling if needed */
        }
        .general-info label{
            font-weight: bold;
        }
        .notes {
            margin-top: 20px
        }
        /* Specific element styling*/
        #recipe-description {
            width: 80%; 
        }
        #recipe-coffee-grind-size{
            width: 80%; 
        }
        #elapsed-time-label {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <h1>Coffee Brew Helper</h1>
    <form action="{% url 'home' %}" method="GET">
        <label for="method-dropdown">Select Method:</label>
        <select id="method-dropdown" name="selected_method_id" onchange="populateRecipes()">
            <option value="">Select a Method</option>
            {% for method in methods %}
                <option value="{{ method.id }}">{{ method.name }}</option>
            {% endfor %}
        </select>

        <label for="recipe-dropdown">Select Recipe:</label>
        <select id="recipe-dropdown" name="selected_recipe_id">
            <option value="">Select a Recipe</option>
            <!-- Recipes will be populated dynamically using JavaScript -->
        </select>

        <input type="submit" value="Select">
    </form>
        
    {% if selected_recipe %}
        <div class="general-info">
            <!-- Element to display recipe header info -->
            <label id = "recipe-description-label" for="recipe-description">
                <span>Description: </span>
                <input type ="text" id="recipe-description" readonly value="{{ selected_recipe.description }}">
            </label>
            <label id = "recipe-coffee-weight-label" for="recipe-coffee-weight">
                <span>Total coffee: </span>
                <input type ="text" id="recipe-coffee-weight" readonly value="{{ selected_recipe.coffee_weight}}">
            </label>
            <label id = "recipe-target-total-water-label" for="recipe-target-total-water">
                <span>Total water: </span>
                <input type ="text" id="recipe-target-total-water" readonly value="{{ selected_recipe.target_total_water }}">
            </label>
            <label id = "recipe-brew-ratio-label" for="recipe-brew-ratio">
                <span>Brew ratio: </span>
                <input type ="text" id="recipe-brew-ratio" readonly value="{{ selected_recipe.brew_ratio }}">
            </label>
            <label id = "recipe-coffee-grind-size-label" for="recipe-coffee-grind-size">
                <span>Grind size: </span>
                <input type ="text" id="recipe-coffee-grind-size" readonly value="{{ selected_recipe.coffee_grind_size }}">
            </label>
            <label id = "recipe-temperature-label" for="recipe-temperature">
                <span>Temperature: </span>
                <input type ="text" id="recipe-temperature" readonly value="{{ selected_recipe.temperature }}">
            </label>
            <label id = "recipe-target-total-time-label" for="recipe-target-total-time">
                <span>Total time: </span>
                <input type ="text" id="recipe-target-total-time" readonly value="{{ selected_recipe.target_total_time }}">
            </label>
            <!-- Element to display elapsed time -->
            <label id = "elapsed-time-label" for="elapsed-time" style="margin-top: 10px">
                <span>Elapsed Time: </span>
                <input type="text" id="elapsed-time" readonly value="00:00">
            </label>
        </div>
        
        <table border="1" id="brewing-steps">
            <thead>
                <tr>
                    <th>Step</th>
                    <th>Description</th>
                    <th>Change in Water</th>
                    <th>Target Water</th>
                    <th>Change in Time</th>
                    <th>Target Time</th>
                    <th>Executed Time</th>
                </tr>
            </thead>
            <tbody>
                {% for step in steps %}
                <tr>
                    <td>{{ step.order_id }}</td>
                    <td>{{ step.description }}</td>
                    <td>{{ step.change_in_water }}</td>
                    <td>{{ step.target_total_water }}</td>
                    <td id="change-in-time-{{ step.change_in_time }}">{{ step.change_in_time }}</td>
                    <td id="target-total-time-{{ step.target_total_time }}">{{ step.target_total_time }}</td>
                    <td id="executed-time-{{ step.order_id }}"></td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    {% endif %}

    <!-- Buttons for controlling the timer -->
    <button id="startPauseButton" onclick="toggleTimer()">Start</button>
    <button onclick="resetTimer()">Reset</button>
    <button onclick="onNextClicked()">Next</button>
    <!-- Checkbox for toggling speech recognition feature -->
    <label for="toggleSpeechRecognition">
        <span>Enable Speech Recognition</span>
        <input type ="checkbox" id="toggleSpeechRecognition" onchange="toggleSpeechRecognition()">
    </label>
    <!-- Keyboard shortcuts note -->
    <div class="notes">
        <p><strong>Note:</strong> Keyboard shortcuts available:</p>
        <ul>
            <li><strong>z:</strong> Start/Pause</li>
            <li><strong>x:</strong> Reset</li>
            <li><strong>c:</strong> Next</li>
        </ul>
    </div>

    <!-- Add any JavaScript scripts or other body elements here -->
    <script>
        // General helpers ///////////////////////////////////////////////////
        function getTimeStringFromSeconds(seconds) {
            const minutes = Math.floor(seconds / 60); // Get minutes
            const remainingSeconds = seconds % 60; // Get remaining seconds

            const formattedMinutes = String(minutes).padStart(2, '0'); // Ensure 2-digit minutes
            const formattedSeconds = String(remainingSeconds).padStart(2, '0'); // Ensure 2-digit seconds

            return `${formattedMinutes}:${formattedSeconds}`; // Format as "mm:ss"
        }
        function getSecondsFromTimeString(timeString) {
            const [minutes, seconds] = timeString.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        // Selecting the recipe //////////////////////////////////////////////
        // Function to populate recipe dropdown base on method
        async function populateRecipes() {
            return new Promise((resolve, reject) => {
                const methodDropdown = document.getElementById('method-dropdown');
                const selectedMethodId = methodDropdown.value;
                const recipeDropdown = document.getElementById('recipe-dropdown');

                // Clear previous options in the recipe dropdown
                recipeDropdown.innerHTML = '<option value="">Select a Recipe</option>';

                if (selectedMethodId !== '') {
                    // AJAX call to fetch recipes associated with the selected method
                    fetch(`/get-recipes?method_id=${selectedMethodId}`)
                        .then(response => response.json())
                        .then(data => {
                            data.forEach(recipe => {
                                const option = document.createElement('option');
                                option.value = recipe.id;
                                option.textContent = recipe.name;
                                recipeDropdown.appendChild(option);
                            });
                            resolve(); // Resolve the Promise once fetching and populating is done
                        })
                        .catch(error => {
                            console.error('Error fetching recipes:', error);
                            reject(error); // Reject the Promise in case of an error
                        });
                } else {
                    resolve(); // Resolve immediately if no method is selected
                }
            });
        }
       
        document.addEventListener('DOMContentLoaded', () => {
            // After Select is hit or the page is refreshed, retain selected method and recipe
            const methodDropdown = document.getElementById('method-dropdown');
            const recipeDropdown = document.getElementById('recipe-dropdown');

            const urlParams = new URLSearchParams(window.location.search);
            const selectedMethodId = urlParams.get('selected_method_id');
            const selectedRecipeId = urlParams.get('selected_recipe_id');
            
            if (selectedMethodId) {
                methodDropdown.value = selectedMethodId;
                // Populate recipes based on the selected method and set the currently selected recipe
                populateRecipes()
                    .then(() => {
                        if (selectedRecipeId) {
                            recipeDropdown.value = selectedRecipeId;
                        }
                    })
                    .catch(error => {
                        // Handle any errors that occurred during populateRecipes
                        console.error('Error in populateRecipes:', error);
                    });
            }

            // Shortcut keys
            document.addEventListener('keydown', event => {
                switch (event.key) {
                    case 'z':
                    case 'Z':
                        toggleTimer(); // Start/Pause when Z key is pressed
                        break;
                    case 'x':
                    case 'X':
                        resetTimer(); // Reset when X key is pressed
                        break;
                    case 'c':
                    case 'C':
                        onNextClicked(); // Next operation when C key is pressed
                        break;
                    default:
                        break;
                }
            });
            
            // Initialize speech recognition
            initSpeechRecognition();
        });
        // Speech Recognition ///////////////////////////////////////////////////////////
        let speechRecognition;
        // Function to initialize speech recognition
        function initSpeechRecognition() {
            // Check browser support for SpeechRecognition
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

                // Configure speech recognition
                speechRecognition.continuous = false; // Enable continuous recognition
                speechRecognition.lang = 'en-US'; // Set the language
                speechRecognition.interimResults = false; // Set to true for interim results
                
                // Define commands and associate with functions                
                isAutoRestart = true;
                
                speechRecognition.onresult = event => {
                    const lastResultIndex = event.results.length - 1;
                    const speechResult = event.results[lastResultIndex][0].transcript.toLowerCase();

                    switch (speechResult) {
                        case 'start':
                        case 'pause':
                            toggleTimer(); // Start/Pause operation
                            break;
                        case 'reset':
                            resetTimer(); // Reset operation
                            break;
                        case 'next':
                            onNextClicked(); // Next operation
                            break;
                        default:
                            break;
                    }
                };

                // Handle errors and other events
                speechRecognition.onerror = event => {
                    switch(event.error){
                        case 'not-allowed':
                        case 'service-not-allowed':
                            // if permission to use the mic is denied, turn off auto-restart
                            isAutoRestart = false;
                            break;
                    }
                    console.error('Speech recognition error:', event.error);
                };

                // Start/stop speech recognition based on checkbox state
                toggleSpeechRecognition();

                // Restart recognition after it ends to enable continuous listening
                speechRecognition.onend = () => {
                    if (isAutoRestart){
                        speechRecognition.start(); // Restart recognition after it ends
                    }
                };
            } else {
                console.log('Speech recognition not supported.');
            }
        }
        // Function to toggle speech recognition based on checkbox state
        function toggleSpeechRecognition() {
            if (speechRecognition) {
                const checkbox = document.getElementById('toggleSpeechRecognition');
                if (checkbox.checked) {
                    isAutoRestart = true;
                    speechRecognition.start(); // Start speech recognition
                } else {
                    isAutoRestart = false;
                    speechRecognition.stop(); // Stop speech recognition
                }
            }
        }
        ////////////////////////////////////////////////////////////////////////
        // Update time data in header info
        const recipeTargetTotalTime = document.getElementById('recipe-target-total-time');
        recipeTargetTotalTime.value = getTimeStringFromSeconds(recipeTargetTotalTime.value);

        // Get all rows of the table
        const rows = document.querySelectorAll('#brewing-steps tbody tr');
        
        let stepIndex = 0;
        let executedStepIndex = 0;
        let elapsedTime = 0;
        let timer;

        let isTimerRunning = false;

        // Update the Time cells in the table        
        function updateTimeCells(timeCells){
            timeCells.forEach(cell => {
            const timeInSeconds = parseInt(cell.textContent);
            cell.textContent = getTimeStringFromSeconds(timeInSeconds);
            });
        }
        const totalTargetTimeCells = document.querySelectorAll('[id^="target-total-time-"]');
        const changeInTimeCells = document.querySelectorAll('[id^="change-in-time-"]');
        updateTimeCells(totalTargetTimeCells)
        updateTimeCells(changeInTimeCells)

        // Function to remove higlight from all steps
        function removeHighlightStep(){
            rows.forEach(row => {
                row.classList.remove('highlighted-step'); // Remove highlight from all rows
            });
        }
        // Function to highlight the current step
        function highlightStep() {
            if (stepIndex < rows.length){
                removeHighlightStep();
                rows[stepIndex].classList.add('highlighted-step'); // Highlight the current step
            }
        }

        // Function to update elapsed time in the input element
        function updateElapsedTime() {
            const elapsedTimeInput = document.getElementById('elapsed-time');
            const formattedTime = getTimeStringFromSeconds(elapsedTime); // Convert elapsed time to "mm:ss"
            elapsedTimeInput.value = formattedTime; // Update input value with formatted time
        }
        
        function toggleTimer() {
            const startPauseButton = document.getElementById('startPauseButton');

            if (!isTimerRunning) { 
                startTimer();
                startPauseButton.textContent = 'Pause'; // Change button text to 'Pause'
            } else {
                pauseTimer();
                startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            }

            isTimerRunning = !isTimerRunning; // Toggle timer status
        }

        // Function to start the timer and highlight steps based on target_total_time
        function startTimer() {
            highlightStep();
            timer = setInterval(() => {
                // Highlight the current step
                if (stepIndex >= rows.length) {
                    // Don't stop timer as it will disrupt the executed completed time
                } else {
                    const currentStepTotalTime = getSecondsFromTimeString(rows[stepIndex].querySelector('[id^="target-total-time-"]').textContent);
                    if (elapsedTime >= currentStepTotalTime) {
                        stepIndex++;
                        highlightStep();
                    }
                }
                elapsedTime += 1; // Increment elapsed time (assuming 1 second intervals)
                updateElapsedTime(); // Update elapsed time in the input element
            }, 1000); // Timer interval: 1 second (adjust as needed)
        }
        // Function to stop the timer
        function pauseTimer() {
            clearInterval(timer);
        }

        // Function to reset the timer and step index
        function resetTimer() {
            // Stop the timer
            clearInterval(timer); 
            const startPauseButton = document.getElementById('startPauseButton');
            startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            isTimerRunning = false;
        
            // Reset test parameters
            stepIndex = 0;
            executedStepIndex = 0;
            elapsedTime = 0;
            removeHighlightStep();
            updateElapsedTime(); // Update elapsed time in the input element

            // Clear the executed-time column
            const timeTakenCells = document.querySelectorAll('[id^="executed-time-"]');
            timeTakenCells.forEach(cell => {
                cell.textContent = ''; // Clear the content of executed-time cells
            });
        }

        // Function to record time taken and update step
        function onNextClicked() {
            // Record current time for the current step
            const currentStepId = executedStepIndex + 1; // Assuming stepIndex starts from 0
            const timeTakenCell = document.getElementById(`executed-time-${currentStepId}`);
            timeTakenCell.textContent = getTimeStringFromSeconds(elapsedTime);

            // Update step for the user
            executedStepIndex++; // Increment step index for the user
        }
    </script>
</body>
</html>
