<!-- home.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coffee Brew Helper</title>
    <!-- Add any CSS links, meta tags, or other head elements here -->
    {% load static %}
    <style>
        /* Key Test Output*/
        .highlighted-step {
            /* Add your CSS styling for highlighting here */
            background-color: yellow; /* Example: Highlight the step with a yellow background */
        }

        /* Header styling */
        h2 {
            margin-top: 20px;
            margin-bottom: 10px; /* Reduce space below section headers */
        }
        h3 {
            margin-top: 20px;
            margin-bottom: 10px; /* Reduce space below section headers */
        }

        /* Section Styling */
        .section {
            display: flex;
            flex-direction: column;
        }
        
        /* List Styling */
        ul {
            margin-top: 0px;
            line-height: 1.5; /* Adjust line spacing within sections */
        }

        /* Paragraph styling */
        p {
            margin-top: 0px;
        }

        /* Input Styling */
        input[type="text"] {
            background: none;
            border: none;
            outline: none;
            width: 80%;
        }

        /* Label Styling */
        label {
            font-weight: bold;
            margin: 0;
            padding: 0;
        }


    </style>
</head>
<body>
    <h1>Coffee Brew Helper</h1>
    <form action="{% url 'home' %}" method="GET">
        <label for="method-dropdown">Select Method:</label>
        <select id="method-dropdown" name="selected_method_id" onchange="populateRecipes()">
            <option value="">Select a Method</option>
            {% for method in methods %}
                <option value="{{ method.id }}">{{ method.name }}</option>
            {% endfor %}
        </select>

        <label for="recipe-dropdown">Select Recipe:</label>
        <select id="recipe-dropdown" name="selected_recipe_id">
            <option value="">Select a Recipe</option>
            <!-- Recipes will be populated dynamically using JavaScript -->
        </select>

        <input type="submit" value="Select">
    </form>
        
    {% if selected_recipe %}
        <div class="section">
            <h2>{{selected_recipe.name}}</h2>
            <!-- Element to display recipe header info -->
            <label id = "recipe-description-label" for="recipe-description">
                <span>Description: </span>
                <input type ="text" id="recipe-description" readonly value="{{ selected_recipe.description }}">
            </label>
            <label id = "recipe-reference-label" for="recipe-reference">
                <span>Reference: </span>
                <input type ="text" id="recipe-reference" readonly value="{{ selected_recipe.reference }}">
            </label>
            <label id = "recipe-coffee-weight-label" for="recipe-coffee-weight">
                <span>Total coffee: </span>
                <input type ="text" id="recipe-coffee-weight" readonly value="{{ selected_recipe.coffee_weight}}g">
            </label>
            <label id = "recipe-target-total-water-label" for="recipe-target-total-water">
                <span>Total water: </span>
                <input type ="text" id="recipe-target-total-water" readonly value="{{ selected_recipe.target_total_water }}g">
            </label>
            <label id = "recipe-brew-ratio-label" for="recipe-brew-ratio">
                <span>Brew ratio: </span>
                <input type ="text" id="recipe-brew-ratio" readonly value="{{ selected_recipe.brew_ratio }}">
            </label>
            <label id = "recipe-coffee-grind-size-label" for="recipe-coffee-grind-size">
                <span>Grind size: </span>
                <input type ="text" id="recipe-coffee-grind-size" readonly value="{{ selected_recipe.coffee_grind_size }}">
            </label>
            <label id = "recipe-temperature-label" for="recipe-temperature">
                <span>Temperature: </span>
                <input type ="text" id="recipe-temperature" readonly value="{{ selected_recipe.temperature }}&deg;C">
            </label>
            <label id = "recipe-target-total-time-label" for="recipe-target-total-time">
                <span>Total time: </span>
                <input type ="text" id="recipe-target-total-time" readonly value="{{ selected_recipe.target_total_time }}">
            </label>
        </div>
        
         <!-- Preparation steps-->
        <div class="section">
            <h3>Preparation</h3>
            {% if preparation_steps %}
                <table border="1" id="preparation-steps">
                    <thead>
                        <tr>
                            <th style="width: 5%;">Step</th>
                            <th style="width: 95%;">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for step in preparation_steps %}
                        <tr>
                            <td id="preparation-step-order-id-{{ step.order_id }}" style="text-align: center;">{{ step.order_id }}</td>
                            <td id="preparation-step-description-{{ step.order_id }}">{{ step.description }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            {% else %}
                <label>No prepration steps</label>
            {% endif %}
        </div>

        <!-- Brew steps-->
        <div class="section">
            <h3>Brew</h3>
            <!-- Element to display elapsed time -->
            <label id = "elapsed-time-label" for="elapsed-time">
                <span>Elapsed Time: </span>
                <input type="text" id="elapsed-time" readonly value="00:00">
            </label>
            <table border="1" id="brewing-steps">
                <thead>
                    <tr>
                        <th style="width: 5%;">Step</th>
                        <th style="width: 70%;">Description</th>
                        <!-- <th>Change in Water</th> -->
                        <th>Target Water</th>
                        <!-- <th>Change in Time</th> -->
                        <th>Target Time</th>
                        <th>Executed Time</th>
                    </tr>
                </thead>
                <tbody>
                    {% for step in brew_steps %}
                    <tr>
                        <td id="brew-step-order-id-{{ step.order_id }}" style="text-align: center;">{{ step.order_id }}</td>
                        <td id="brew-step-description-{{ step.order_id }}">{{ step.description }}</td>
                        <!-- <td>{{ step.change_in_water }}</td> -->
                        <td id="brew-step-target-total-water-{{ step.order_id }}" style="text-align: center;">{{ step.target_total_water }}g</td>
                        <!-- <td id="change-in-time-{{ step.order_id }}">{{ step.change_in_time }}</td> -->
                        <td id="brew-step-target-total-time-{{ step.order_id }}"  style="text-align: center;">{{ step.target_total_time }}</td>
                        <td id="brew-step-executed-time-{{ step.order_id }}"  style="text-align: center;"></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Buttons for controlling the timer -->
        <audio id="startStepBeepSound" src="{% static 'brewhelper/audio/startStepBeep128.mp3' %}" type="audio/mpeg"></audio>
        <audio id="warningStepEndBeepsSound" src="{% static 'brewhelper/audio/warningStepEndBeeps128.mp3' %}" type="audio/mpeg"></audio>
        <button id="startPauseButton" onclick="toggleTimer()">Start</button>
        <button onclick="resetTimer()">Reset</button>
        <button onclick="onDoneClicked()">Done</button>
        
        <!-- Speech Settings -->
        <div class="section">
            <h2>Speech Settings</h2>
            <p><!-- Checkbox for toggling read steps outloud feature -->
                <label for="toggleReadBrewStepsOutloud">
                    <input type ="checkbox" id="toggleReadBrewStepsOutloud" onchange="toggleReadBrewStepsOutloud()">
                    <span><strong>Enable Read Brew Steps Outloud</strong></span>
                </label>
            </p>
            <p><!-- Checkbox for toggling voice commands feature -->
                <label for="toggleVoiceCommands">
                    <input type ="checkbox" id="toggleVoiceCommands" onchange="toggleVoiceCommands()">
                    <span><strong>Enable Voice Commands</strong></span>
                </label>
            </p>
            <p class="detected-voice-command-label">
                <label for="detected-voice-command"><span>Last Detected Command: </span></label>
                <input type="text" id="detected-voice-command" readonly value="">
            </p>
            <p class="voice-command-list-title-label"><label>Accepted Commands:</label></p>
            <ul class="voice-command-list">
                <li>Start</li>
                <li>Pause</li>
                <li>Reset</li>
                <li>Done</li>
            </ul>
        </div>

        <!-- Keyboard shortcuts note -->
        <div class="section">
            <h2>Keyboard Shortcuts:</h2>
            <div class="keyboard-shortcut-info">
                <ul class="keyboard-shortcut-list">
                    <li><strong>z:</strong> Start/Pause</li>
                    <li><strong>x:</strong> Reset</li>
                    <li><strong>c:</strong> Done</li>
                </ul>
            </div>
        </div>

    {% else %}
        <div class="section">
            <h2>[No Recipe Selected]</h2>
        </div>
    {% endif %}
    
    <!-- Add any JavaScript scripts or other body elements here -->
    <script>
        // General helpers ///////////////////////////////////////////////////
        function getTimeStringFromSeconds(seconds) {
            const minutes = Math.floor(seconds / 60); // Get minutes
            const remainingSeconds = seconds % 60; // Get remaining seconds

            const formattedMinutes = String(minutes).padStart(2, '0'); // Ensure 2-digit minutes
            const formattedSeconds = String(remainingSeconds).padStart(2, '0'); // Ensure 2-digit seconds

            return `${formattedMinutes}:${formattedSeconds}`; // Format as "mm:ss"
        }
        function getSecondsFromTimeString(timeString) {
            const [minutes, seconds] = timeString.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        // Selecting the recipe //////////////////////////////////////////////
        // Function to populate recipe dropdown base on method
        async function populateRecipes() {
            return new Promise((resolve, reject) => {
                const methodDropdown = document.getElementById('method-dropdown');
                const selectedMethodId = methodDropdown.value;
                const recipeDropdown = document.getElementById('recipe-dropdown');

                // Clear previous options in the recipe dropdown
                recipeDropdown.innerHTML = '<option value="">Select a Recipe</option>';

                if (selectedMethodId !== '') {
                    // AJAX call to fetch recipes associated with the selected method
                    fetch(`/get-recipes?method_id=${selectedMethodId}`)
                        .then(response => response.json())
                        .then(data => {
                            data.forEach(recipe => {
                                const option = document.createElement('option');
                                option.value = recipe.id;
                                option.textContent = recipe.name;
                                recipeDropdown.appendChild(option);
                            });
                            resolve(); // Resolve the Promise once fetching and populating is done
                        })
                        .catch(error => {
                            console.error('Error fetching recipes:', error);
                            reject(error); // Reject the Promise in case of an error
                        });
                } else {
                    resolve(); // Resolve immediately if no method is selected
                }
            });
        }
       
        document.addEventListener('DOMContentLoaded', () => {
            // After Select is hit or the page is refreshed, retain selected method and recipe
            const methodDropdown = document.getElementById('method-dropdown');
            const recipeDropdown = document.getElementById('recipe-dropdown');

            const urlParams = new URLSearchParams(window.location.search);
            const selectedMethodId = urlParams.get('selected_method_id');
            const selectedRecipeId = urlParams.get('selected_recipe_id');
            
            if (selectedMethodId) {
                methodDropdown.value = selectedMethodId;
                // Populate recipes based on the selected method and set the currently selected recipe
                populateRecipes()
                    .then(() => {
                        if (selectedRecipeId) {
                            recipeDropdown.value = selectedRecipeId;
                        }
                    })
                    .catch(error => {
                        // Handle any errors that occurred during populateRecipes
                        console.error('Error in populateRecipes:', error);
                    });
            }

            // Shortcut keys
            document.addEventListener('keydown', event => {
                switch (event.key) {
                    case 'z':
                    case 'Z':
                        toggleTimer(); // Start/Pause when Z key is pressed
                        break;
                    case 'x':
                    case 'X':
                        resetTimer(); // Reset when X key is pressed
                        break;
                    case 'c':
                    case 'C':
                        onDoneClicked(); // Done operation when C key is pressed
                        break;
                    default:
                        break;
                }
            });
            
            // Initialize read outloud
            // Wait for voice list to load (aync to the page) before using them in speech functions
            window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = function(){
                voices = window.speechSynthesis.getVoices();
            }
            // Initialize voice commands
            initVoiceCommands();
        });
        
        // Speech Features ///////////////////////////////////////////////////////
        // read steps outloud ////
        let isReadStepsOutloud = false;
        let voices;
        // Function to set read steps outloud flag based on checkbox state
        function toggleReadBrewStepsOutloud() {
            const checkbox = document.getElementById('toggleReadBrewStepsOutloud');
            isReadStepsOutloud = checkbox.checked;
            if (!isReadStepsOutloud) {
                cancelReadStepDescription();
            }
        }
        // Function to read the description aloud
        function readStepDescription() {
            if (!isReadStepsOutloud){
                return;
            }
            // Clear old utterances
            cancelReadStepDescription();
            // Create utterance from latest step description
            const description = brewSteps[brewStepIndex].querySelector('[id^="brew-step-description-"]').textContent
            const utterance = new SpeechSynthesisUtterance(description);
            // set voice
            utterance.voice = voices[4]; //for now we hardcode one
            // Read description
            window.speechSynthesis.speak(utterance);
        }
        // Function to pause reading description
        function pauseReadStepDescription(){
            if (window.speechSynthesis.speaking){
                window.speechSynthesis.pause();
            }
        }
        // Function to cancel reading all descriptions
        function cancelReadStepDescription(){
            if (window.speechSynthesis.speaking){
                window.speechSynthesis.cancel();
            }
        }

        // voice commands for Voice Commands ////
        let voiceCommands;
        // Function to initialize voice commands
        function initVoiceCommands() {
            // Check browser support for SpeechRecognition
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                voiceCommands = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

                // Configure voice commands
                voiceCommands.continuous = false; // Enable continuous recognition
                voiceCommands.lang = 'en-US'; // Set the language
                voiceCommands.interimResults = false; // Set to true for interim results
                
                // Define commands and associate with functions                
                isAutoRestart = true;
                
                voiceCommands.onresult = event => {
                    const lastResultIndex = event.results.length - 1;
                    const speechResult = event.results[lastResultIndex][0].transcript.toLowerCase();
                    
                    // Split the speechResult into words and extract the last word spoken
                    const words = speechResult.split(' ');
                    const lastWord = words[words.length - 1];
                    
                    // Compare last word to accepted list of commands
                    switch (lastWord) {
                        case 'start':
                        case 'pause':
                            toggleTimer(); // Start/Pause operation
                            break;
                        case 'reset':
                            resetTimer(); // Reset operation
                            break;
                        case 'done':
                            onDoneClicked(); // Done operation
                            break;
                        default:
                            break;
                    }
                    // Update user with last word detected
                    updateDetectedVoiceCommand(lastWord)
                };

                // Handle errors and other events
                voiceCommands.onerror = event => {
                    switch(event.error){
                        case 'not-allowed':
                        case 'service-not-allowed':
                            // if permission to use the mic is denied, turn off auto-restart
                            isAutoRestart = false;
                            break;
                    }
                    console.error('voice commands error:', event.error);
                };

                // Start/stop voice commands based on checkbox state
                toggleVoiceCommands();

                // Restart recognition after it ends to enable continuous listening
                voiceCommands.onend = () => {
                    //updateDetectedVoiceCommand(); //clear shown detected command
                    if (isAutoRestart){
                        voiceCommands.start(); // Restart recognition after it ends
                    }
                };
            } else {
                console.log('voice commands not supported.');
            }
        }
        // Function to toggle voice commands based on checkbox state
        function toggleVoiceCommands() {
            if (voiceCommands) {
                const checkbox = document.getElementById('toggleVoiceCommands');
                if (checkbox.checked) {
                    isAutoRestart = true;
                    voiceCommands.start(); // Start voice commands
                } else {
                    updateDetectedVoiceCommand(); //clear shown detected command
                    isAutoRestart = false;
                    voiceCommands.stop(); // Stop voice commands
                }
            }
        }
        // Function to update detected voice command in the input element, defaults to empty string (clear)
        function updateDetectedVoiceCommand(detecedVoiceCommandResult = "[No Word Detected]") {
            const detecedVoiceCommandInput = document.getElementById('detected-voice-command');
            detecedVoiceCommandInput.value = detecedVoiceCommandResult ; // Update input value with speech recognition result
        }

        ////////////////////////////////////////////////////////////////////////
        // Update time data in header info
        const recipeTargetTotalTime = document.getElementById('recipe-target-total-time');
        recipeTargetTotalTime.value = getTimeStringFromSeconds(recipeTargetTotalTime.value);

        // Get all rows of the table
        const brewSteps = document.querySelectorAll('#brewing-steps tbody tr');
        
        let brewStepIndex = 0;
        let executedBrewStepIndex = 0;
        let elapsedTime = 0;
        let timer;

        let isTimerRunning = false;

        // Update the Time cells in the table        
        function updateTimeCells(timeCells){
            timeCells.forEach(cell => {
            const timeInSeconds = parseInt(cell.textContent);
            cell.textContent = getTimeStringFromSeconds(timeInSeconds);
            });
        }
        const totalTargetTimeCells = document.querySelectorAll('[id^="brew-step-target-total-time-"]');
        //const changeInTimeCells = document.querySelectorAll('[id^="brew-step-change-in-time-"]');
        updateTimeCells(totalTargetTimeCells)
        //updateTimeCells(changeInTimeCells)

        // Function to remove higlight from all steps
        function removeHighlighBrewStep(){
            brewSteps.forEach(row => {
                row.classList.remove('highlighted-step'); // Remove highlight from all rows
            });
        }
        // Function to highlight the current step
        function highlightBrewStep() {
            if (brewStepIndex < brewSteps.length){
                removeHighlighBrewStep();
                brewSteps[brewStepIndex].classList.add('highlighted-step'); // Highlight the current step
            }
        }

        // Function to update elapsed time in the input element
        function updateElapsedTime() {
            const elapsedTimeInput = document.getElementById('elapsed-time');
            const formattedTime = getTimeStringFromSeconds(elapsedTime); // Convert elapsed time to "mm:ss"
            elapsedTimeInput.value = formattedTime; // Update input value with formatted time
        }
        
        function toggleTimer() {
            const startPauseButton = document.getElementById('startPauseButton');

            if (!isTimerRunning) { 
                startTimer();
                startPauseButton.textContent = 'Pause'; // Change button text to 'Pause'
            } else {
                pauseTimer();
                startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            }

            isTimerRunning = !isTimerRunning; // Toggle timer status
        }

        // Function to start the timer and highlight brew steps based on target_total_time
        function startTimer() {
            if (elapsedTime === 0){
                const startStepAudio = document.getElementById('startStepBeepSound');
                startStepAudio.play();
            }
            highlightBrewStep();
            readStepDescription();
            timer = setInterval(() => {
                elapsedTime += 1; // Increment elapsed time (assuming 1 second intervals)
                updateElapsedTime(); // Update elapsed time in the input element
                // Highlight the current step
                if (brewStepIndex >= brewSteps.length) {
                    // Don't stop timer as it will disrupt the executed completed time
                } else {
                    const currentStepTotalTime = getSecondsFromTimeString(brewSteps[brewStepIndex].querySelector('[id^="brew-step-target-total-time-"]').textContent);
                    
                    // Play warning beep 3 seconds before step change
                    if (elapsedTime >= currentStepTotalTime - 3) {
                        const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
                        if (warningStepEndAudio.paused){
                            warningStepEndAudio.play();
                        }
                    }
                    
                    if (elapsedTime >= currentStepTotalTime) {
                        brewStepIndex++;
                        const startStepAudio = document.getElementById('startStepBeepSound');
                        if (startStepAudio.paused){
                            startStepAudio.play();
                        }
                        highlightBrewStep();
                        readStepDescription();
                    }
                }
            }, 1000); // Timer interval: 1 second (adjust as needed)
        }
        // Function to stop the timer
        function pauseTimer() {
            clearInterval(timer);
            const startStepAudio = document.getElementById('startStepBeepSound');
            startStepAudio.pause();
            const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
            warningStepEndAudio.pause();
            cancelReadStepDescription(); //better to cancel and restart reading
        }

        // Function to reset the timer and step index
        function resetTimer() {
            // Stop the timer
            pauseTimer(timer);
            const startPauseButton = document.getElementById('startPauseButton');
            startPauseButton.textContent = 'Start'; // Change button text to 'Start'
            isTimerRunning = false;
        
            // Reset test parameters
            brewStepIndex = 0;
            executedBrewStepIndex = 0;
            elapsedTime = 0;
            const startStepAudio = document.getElementById('startStepBeepSound');
            startStepAudio.currentTime = 0;
            const warningStepEndAudio = document.getElementById('warningStepEndBeepsSound');
            warningStepEndAudio.currentTime = 0;
            cancelReadStepDescription();
            removeHighlighBrewStep();
            updateElapsedTime(); // Update elapsed time in the input element

            // Clear the executed-time column
            const timeTakenCells = document.querySelectorAll('[id^="brew-step-executed-time-"]');
            timeTakenCells.forEach(cell => {
                cell.textContent = ''; // Clear the content of executed-time cells
            });
        }

        // Function to record time taken and update step
        function onDoneClicked() {
            // Record current time for the current step
            const currentStepId = executedBrewStepIndex + 1; // Assuming stepIndex starts from 0
            const timeTakenCell = document.getElementById(`brew-step-executed-time-${currentStepId}`);
            timeTakenCell.textContent = getTimeStringFromSeconds(elapsedTime);

            // Update step for the user
            executedBrewStepIndex++; // Increment step index for the user
        }
    </script>
</body>
</html>
